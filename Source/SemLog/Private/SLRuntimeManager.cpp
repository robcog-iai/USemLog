// Copyright 2017, Institute for Artificial Intelligence - University of Bremen
// Author: Andrei Haidu (http://haidu.eu)

#include "SLRuntimeManager.h"
#include "SLLevelInfo.h"
#include "SLUtils.h"

// Sets default values
ASLRuntimeManager::ASLRuntimeManager()
{
	PrimaryActorTick.bCanEverTick = true;

	// Defaults
	bStartAtLoadTime = true;
	bIsInit = false;
	bIsStarted = false;
	bIsFinished = false;
	LogDirectory = FPaths::ProjectDir() + "SemLog";
	EpisodeId = "AutoGenerated";
	
	bLogRawData = true;
	RawDataUpdateRate = 0.f;
	RawDataDistanceThreshold = 0.5f;
	TimePassedSinceLastUpdate = 0.f;
	bWriteRawDataToFile = true;
	bBroadcastRawData = false;
	
	bLogEventData = true;
	bWriteEventDataToFile = true;
	bWriteEventTimelines = false;
	bBroadcastEventData = false;

	// Event filter
	bFilterEvents = false;
	bFilterAll = false;
	MinDurationFilter = 0.1;

	// Concatenate events
	bConcatenateEvents = false;
	bConcatenateBeforeFilter = false;
	bConcatenateAll = false;
	MinDurationConcatenate = 0.1;
}

// Make sure the manager is started before event publishers call BeginPlay
void ASLRuntimeManager::PostInitializeComponents()
{
	Super::PostInitializeComponents();

	// No tick by default
	SetActorTickEnabled(false);

	// Init manager
	ASLRuntimeManager::Init();

	// Start manager at load time
	if (bStartAtLoadTime)
	{
		ASLRuntimeManager::Start();
	}
}

// Called when the game starts or when spawned
void ASLRuntimeManager::BeginPlay()
{
	Super::BeginPlay();
}

// Called when actor removed from game or game ended
void ASLRuntimeManager::EndPlay(const EEndPlayReason::Type EndPlayReason)
{
	ASLRuntimeManager::Finish();
}

// Called every frame
void ASLRuntimeManager::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);
	
	// Increase duration
	TimePassedSinceLastUpdate += DeltaTime;

	if (RawDataUpdateRate < TimePassedSinceLastUpdate)
	{
		// Log the raw data of the dynamic entities
		RawDataLogger->LogDynamicEntities();
		TimePassedSinceLastUpdate = 0.f;
	}
}

// Init loggers
void ASLRuntimeManager::Init()
{
	if (!bIsInit)
	{
		// Generate episode Id if not manually entered
		if (EpisodeId.Equals("AutoGenerated"))
		{
			EpisodeId = FSLUtils::GenerateRandomFString(4);
		}

		// Setup raw data logger
		if (bLogRawData)
		{
			// Create raw data logger UObject
			RawDataLogger = NewObject<USLRawDataLogger>(this, TEXT("RawDataLogger"));

			// Init logger 
			RawDataLogger->Init(GetWorld(), RawDataDistanceThreshold);

			// Set logging type
			if (bWriteRawDataToFile)
			{
				RawDataLogger->InitFileHandle(EpisodeId, LogDirectory);
			}

			if (bBroadcastRawData)
			{
				RawDataLogger->InitBroadcaster();
			}
		}

		// Setup event data logger
		if (bLogEventData)
		{
			// Create event data logger UObject
			EventDataLogger = NewObject<USLEventDataLogger>(this, TEXT("EventDataLogger"));

			// Initialize the event data
			EventDataLogger->InitLogger(EpisodeId);

			// Set filter parameters
			EventDataLogger->SetFilterParameters(bFilterEvents, MinDurationFilter, bFilterAll, FilterKeywords);

			// Set concatenate parameters
			EventDataLogger->SetConcatenateParameters(bConcatenateEvents, MinDurationConcatenate, bConcatenateBeforeFilter, bConcatenateAll, ConcatenateKeywords);
		}

		// Set the manager as initialized
		bIsInit = true;
	}
}

// Start loggers
void ASLRuntimeManager::Start()
{
	if (bIsInit && !bIsStarted)
	{
		if (bLogRawData)
		{
			// Enable tick for raw data logging
			SetActorTickEnabled(true);

			// Log the first entry (static and dynamic entities) of the raw data
			RawDataLogger->LogFirstEntry();
		}

		if (bLogEventData)
		{
			// Start logger
			EventDataLogger->StartLogger(GetWorld()->GetTimeSeconds());

			// Add level info to the metadata
			for (TActorIterator<ASLLevelInfo> LevelInfoItr(GetWorld()); LevelInfoItr; ++LevelInfoItr)
			{
				if (LevelInfoItr->LevelKeyToProperties.Contains(LevelInfoItr->LevelKey))
				{
					for (const auto& PropItr : LevelInfoItr->LevelKeyToProperties[LevelInfoItr->LevelKey].LevelProperties)
					{
						EventDataLogger->AddMetadataProperty(MakeShareable(new FOwlTriple(PropItr)));
					}
				}
			}
		}

		// Mark as started
		bIsStarted = true;
	}
}

// Finish loggers
void ASLRuntimeManager::Finish()
{
	if (bIsStarted && !bIsFinished)
	{
		if (bLogEventData && EventDataLogger)
		{
			// Finish up the logger - Terminate idle events
			EventDataLogger->FinishLogger(GetWorld()->GetTimeSeconds());

			if (bWriteEventDataToFile)
			{
				EventDataLogger->WriteEventsToFile(LogDirectory, bWriteEventTimelines);
			}

			if (bBroadcastEventData)
			{
				EventDataLogger->BroadcastFinishedEvents();
			}
		}

		// Mark as finished
		bIsFinished = true;
	}
}

// Add finished event
bool ASLRuntimeManager::AddFinishedEvent(TSharedPtr<FOwlNode> Event)
{
	if (bLogEventData && EventDataLogger)
	{		
		return EventDataLogger->InsertFinishedEvent(Event);
	}
	return false;
}

// Start an event
bool ASLRuntimeManager::StartEvent(TSharedPtr<FOwlNode> Event)
{
	if (bLogEventData && EventDataLogger)
	{
		// Add event start time
		Event->Properties.Emplace(FOwlTriple(
			"knowrob:startTime", 
			"rdf:resource",
			"&log;timepoint_" + FString::SanitizeFloat(GetWorld()->GetTimeSeconds())));
		return EventDataLogger->StartAnEvent(Event);
	}
	return false;
}

// Finish an event
bool ASLRuntimeManager::FinishEvent(TSharedPtr<FOwlNode> Event)
{
	if (bLogEventData && EventDataLogger)
	{
		// Add event end time
		Event->Properties.Emplace(FOwlTriple(
			"knowrob:endTime",
			"rdf:resource",
			"&log;timepoint_" + FString::SanitizeFloat(GetWorld()->GetTimeSeconds())));
		return EventDataLogger->FinishAnEvent(Event);
	}
	return false;
}

// Add metadata property
bool ASLRuntimeManager::AddMetadataProperty(TSharedPtr<FOwlTriple> Property)
{
	if (bLogEventData && EventDataLogger)
	{
		return EventDataLogger->AddMetadataProperty(Property);
	}
	return false;
}

// Add new entity to be logged
void ASLRuntimeManager::AddNewEntity(AActor* Actor)
{
	if (bLogRawData && RawDataLogger)
	{
		// Add new entity to be logged
		RawDataLogger->AddNewDynamicEntity(Actor);
	}

	if (bLogEventData && EventDataLogger)
	{
		// Check if actor has a semantic description
		int32 TagIndex = FTagStatics::GetTagTypeIndex(Actor->Tags, "SemLog");

		// If tag type exist, read the Class and the Id
		if (TagIndex != INDEX_NONE)
		{
			// Get the Class and Id from the semantic description
			const FString OtherActorClass = FTagStatics::GetKeyValue(Actor->Tags[TagIndex], "Class");
			const FString OtherActorId = FTagStatics::GetKeyValue(Actor->Tags[TagIndex], "Id");

			// Example event
			/********************************************************************
			<!-- Event node described with a FOwlTriple (Subject-Predicate-Object) and Properties: -->
			<owl:NamedIndividual rdf:about="&log;CreateEntity_OhnU">
			<!-- List of the event properties as FOwlTriple (Subject-Predicate-Object): -->
				<rdf:type rdf:resource="&knowrob_u;CreateEntity"/>
				<knowrob:taskContext rdf:datatype="&xsd;string">CreateEntity-SliceTomato_o5Ol</knowrob:taskContext>
				<knowrob:objectActedOn rdf:resource="&log;SliceTomato_o5Ol"/>
				<knowrob:startTime rdf:resource="&log;timepoint_11.263422"/>
				<knowrob:endTime rdf:resource="&log;timepoint_11.263422"/>
			</owl:NamedIndividual>
			*********************************************************************/

			// Create event
			const FOwlIndividualName OtherIndividual("log", OtherActorClass, OtherActorId);
			const FOwlIndividualName CreateEntityIndividual("log", "CreateEntity", FSLUtils::GenerateRandomFString(4));

			// Owl prefixed names
			const FOwlPrefixName RdfType("rdf", "type");
			const FOwlPrefixName RdfAbout("rdf", "about");
			const FOwlPrefixName RdfResource("rdf", "resource");
			const FOwlPrefixName RdfDatatype("rdf", "datatype");
			const FOwlPrefixName TaskContext("knowrob", "taskContext");
			const FOwlPrefixName ObjectActedOn("knowrob", "objectActedOn");
			const FOwlPrefixName OwlNamedIndividual("owl", "NamedIndividual");

			// Owl classes
			const FOwlClass XsdString("xsd", "string");
			const FOwlClass CreateEntity("knowrob_u", "CreateEntity");

			// Add the event properties
			TArray <FOwlTriple> Properties;
			Properties.Emplace(FOwlTriple(RdfType, RdfResource, CreateEntity));
			Properties.Emplace(FOwlTriple(TaskContext, RdfDatatype, XsdString,
				"CreateEntity-" + OtherIndividual.GetName()));
			Properties.Emplace(FOwlTriple(ObjectActedOn, RdfResource, OtherIndividual));
			Properties.Emplace(FOwlTriple("knowrob:startTime", "rdf:resource",
				"&log;timepoint_" + FString::SanitizeFloat(GetWorld()->GetTimeSeconds())));
			Properties.Emplace(FOwlTriple("knowrob:endTime", "rdf:resource",
				"&log;timepoint_" + FString::SanitizeFloat(GetWorld()->GetTimeSeconds())));

			// Create the event
			TSharedPtr<FOwlNode> CreateEntityEvent = MakeShareable(new FOwlNode(
				OwlNamedIndividual, RdfAbout, CreateEntityIndividual, Properties));

			EventDataLogger->InsertFinishedEvent(CreateEntityEvent);
		}
	}
}

// Remove entity from logging
void ASLRuntimeManager::RemoveEntity(AActor* Actor)
{
	if (bLogRawData && RawDataLogger)
	{
		// Remove entity from logging
		RawDataLogger->RemoveDynamicEntity(Actor);
	}

	if (bLogEventData && EventDataLogger)
	{
		// Check if actor has a semantic description
		int32 TagIndex = FTagStatics::GetTagTypeIndex(Actor->Tags, "SemLog");

		// If tag type exist, read the Class and the Id
		if (TagIndex != INDEX_NONE)
		{
			// Get the Class and Id from the semantic description
			const FString OtherActorClass = FTagStatics::GetKeyValue(Actor->Tags[TagIndex], "Class");
			const FString OtherActorId = FTagStatics::GetKeyValue(Actor->Tags[TagIndex], "Id");

			// Example event
			/********************************************************************
			<!-- Event node described with a FOwlTriple (Subject-Predicate-Object) and Properties: -->
			<owl:NamedIndividual rdf:about="&log;DestroyEntity_OhnU">
			<!-- List of the event properties as FOwlTriple (Subject-Predicate-Object): -->
				<rdf:type rdf:resource="&knowrob_u;DestroyEntity"/>
				<knowrob:taskContext rdf:datatype="&xsd;string">DestroyEntity-Tomato_o5Ol</knowrob:taskContext>
				<knowrob:objectActedOn rdf:resource="&log;Tomato_o5Ol"/>
				<knowrob:startTime rdf:resource="&log;timepoint_11.263422"/>
				<knowrob:endTime rdf:resource="&log;timepoint_11.263422"/>
			</owl:NamedIndividual>
			*********************************************************************/

			// Create event
			const FOwlIndividualName OtherIndividual("log", OtherActorClass, OtherActorId);
			const FOwlIndividualName DestroyEntityIndividual("log", "DestroyEntity", FSLUtils::GenerateRandomFString(4));

			// Owl prefixed names
			const FOwlPrefixName RdfType("rdf", "type");
			const FOwlPrefixName RdfAbout("rdf", "about");
			const FOwlPrefixName RdfResource("rdf", "resource");
			const FOwlPrefixName RdfDatatype("rdf", "datatype");
			const FOwlPrefixName TaskContext("knowrob", "taskContext");
			const FOwlPrefixName ObjectActedOn("knowrob", "objectActedOn");
			const FOwlPrefixName OwlNamedIndividual("owl", "NamedIndividual");

			// Owl classes
			const FOwlClass XsdString("xsd", "string");
			const FOwlClass DestroyEntity("knowrob_u", "DestroyEntity");

			// Add the event properties
			TArray <FOwlTriple> Properties;
			Properties.Emplace(FOwlTriple(RdfType, RdfResource, DestroyEntity));
			Properties.Emplace(FOwlTriple(TaskContext, RdfDatatype, XsdString,
				"DestroyEntity-" + OtherIndividual.GetName()));
			Properties.Emplace(FOwlTriple(ObjectActedOn, RdfResource, OtherIndividual));
			Properties.Emplace(FOwlTriple("knowrob:startTime", "rdf:resource",
				"&log;timepoint_" + FString::SanitizeFloat(GetWorld()->GetTimeSeconds())));
			Properties.Emplace(FOwlTriple("knowrob:endTime", "rdf:resource",
				"&log;timepoint_" + FString::SanitizeFloat(GetWorld()->GetTimeSeconds())));

			// Create the event
			TSharedPtr<FOwlNode> DestroyEntityEvent = MakeShareable(new FOwlNode(
				OwlNamedIndividual, RdfAbout, DestroyEntityIndividual, Properties));

			EventDataLogger->InsertFinishedEvent(DestroyEntityEvent);
		}
	}
}